What is SQL?|SQL (Structured Query Language) is a standard language for storing, manipulating, and retrieving data in relational databases.| ||Database diagram
What is a relational database?|A relational database is a type of database that stores and provides access to data points that are related to one another. Data is organized into tables (relations), which consist of rows and columns.| ||Relational database table
What is a table in SQL?|A table is a collection of related data organized in rows and columns. Each column represents a specific attribute, and each row represents a single record or entry.| ||Table structure
What is a column in SQL?|A column (or field) is a vertical entity in a table that contains all the data entries of a particular type, for example, all customer names or all product prices.| ||Table column
What is a row in SQL?|A row (or record/tuple) is a horizontal entity in a table that represents a single, complete set of related data. For example, all information about one specific customer or one specific product.| ||Table row
What is a Primary Key?|A Primary Key is a column or set of columns in a table that uniquely identifies each row in that table. It must contain unique values and cannot contain NULL values.| ||Primary key diagram
What is a Foreign Key?|A Foreign Key is a column or set of columns in a table that refers to the Primary Key in another table. It establishes a link between two tables, enforcing referential integrity.| ||Foreign key diagram
What are Data Types in SQL and why are they important?|Data types specify the type of data that a column can hold (e.g., integers, text, dates). They are important for ensuring data integrity, optimizing storage, and performing correct operations.| ||
Name three common SQL data types for numbers.|INT (integer), DECIMAL (fixed-point number), FLOAT (floating-point number).| ||
Name three common SQL data types for text.|VARCHAR (variable-length string), CHAR (fixed-length string), TEXT (large text data).| ||
Name two common SQL data types for dates and times.|DATE (date only), DATETIME (date and time), TIMESTAMP (date and time with timezone considerations, often).| ||
What is DDL in SQL?|DDL (Data Definition Language) commands are used to define, modify, and delete database structures like tables, indexes, and views.| ||
What is DML in SQL?|DML (Data Manipulation Language) commands are used for managing data within schema objects. These commands affect the information in the database.| ||
What is DCL in SQL?|DCL (Data Control Language) commands are used to manage user permissions and access control to the database.| ||
What is the CREATE DATABASE statement used for?|CREATE DATABASE is a DDL command used to create a new database.|<pre><code>CREATE DATABASE my_new_database;</code></pre>|
What is the CREATE TABLE statement used for?|CREATE TABLE is a DDL command used to create a new table in a database.|<pre><code>CREATE TABLE Customers (<br>    CustomerID INT PRIMARY KEY,<br>    CustomerName VARCHAR(255),<br>    City VARCHAR(100)<br>);</code></pre>|
How do you add a new column to an existing table?|Use the ALTER TABLE ADD COLUMN statement.|<pre><code>ALTER TABLE Customers<br>ADD Email VARCHAR(255);</code></pre>|
How do you modify an existing column's data type or size?|Use the ALTER TABLE MODIFY COLUMN (or ALTER COLUMN depending on dialect) statement.|<pre><code>ALTER TABLE Customers<br>ALTER COLUMN CustomerName VARCHAR(100); -- SQL Server syntax<br><br>-- MySQL syntax:<br>ALTER TABLE Customers<br>MODIFY COLUMN CustomerName VARCHAR(100);</code></pre>|
How do you delete a column from an existing table?|Use the ALTER TABLE DROP COLUMN statement.|<pre><code>ALTER TABLE Customers<br>DROP COLUMN Email;</code></pre>|
What is the DROP TABLE statement used for?|DROP TABLE is a DDL command used to delete an existing table from a database entirely, including all its data, indexes, and constraints.|<pre><code>DROP TABLE Customers;</code></pre>|
What is the TRUNCATE TABLE statement used for?|TRUNCATE TABLE removes all rows from a table, but the table structure, columns, indexes, and constraints remain. It's faster than DELETE for removing all rows and cannot be rolled back in some systems.|<pre><code>TRUNCATE TABLE Orders;</code></pre>|
What is the primary purpose of the SELECT statement in SQL?|The SELECT statement is used to retrieve data from one or more tables in a database.|<pre><code>SELECT column1, column2 FROM table_name;</code></pre>|
How do you select all columns from a table named Employees?|You use the asterisk (*) wildcard to select all columns.|<pre><code>SELECT * FROM Employees;</code></pre>|
What is the FROM clause used for in a SQL query?|The FROM clause specifies the table or tables from which to retrieve data.|<pre><code>SELECT column_name FROM table_name;</code></pre>|
Explain the basic function of the WHERE clause.|The WHERE clause is used to filter records, extracting only those that fulfill a specified condition.|<pre><code>SELECT * FROM Products WHERE Price > 50;</code></pre>|
How do you filter results to show only distinct (unique) values in a column?|Use the DISTINCT keyword.|<pre><code>SELECT DISTINCT City FROM Customers;</code></pre>|
What is the purpose of the ORDER BY clause?|The ORDER BY clause is used to sort the result-set of a query in ascending (ASC) or descending (DESC) order.|<pre><code>SELECT Name, Age FROM Students ORDER BY Age DESC;</code></pre>|
How do you sort results in ascending order by default?|If you don't specify ASC or DESC, ORDER BY sorts in ascending order by default.|<pre><code>SELECT ProductName FROM Products ORDER BY ProductName;</code></pre>|
What are the main types of SQL joins?|The main types are INNER JOIN, LEFT JOIN (or LEFT OUTER JOIN), RIGHT JOIN (or RIGHT OUTER JOIN), and FULL JOIN (or FULL OUTER JOIN).|<pre><code>-- Example of INNER JOIN<br>SELECT Orders.OrderID, Customers.CustomerName<br>FROM Orders<br>INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre>|
Explain the difference between INNER JOIN and LEFT JOIN.|An INNER JOIN returns only rows that have matching values in both tables. A LEFT JOIN returns all rows from the left table, and the matching rows from the right table. If there's no match, NULLs are returned for the right table's columns.|<pre><code>-- INNER JOIN example<br>SELECT A.id, B.value FROM TableA A INNER JOIN TableB B ON A.id = B.id;<br><br>-- LEFT JOIN example<br>SELECT A.id, B.value FROM TableA A LEFT JOIN TableB B ON A.id = B.id;</code></pre>|
How do you count the number of rows in a table?|Use the COUNT() aggregate function, typically COUNT(*).|<pre><code>SELECT COUNT() FROM Orders;</code></pre>|
What is the GROUP BY clause used for?|The GROUP BY clause groups rows that have the same values in specified columns into summary rows, typically used with aggregate functions.|<pre><code>SELECT Country, COUNT(CustomerID) FROM Customers GROUP BY Country;</code></pre>|
What is the difference between COUNT(*) and COUNT(column_name)?|COUNT(*) counts all rows, including those with NULL values in any column. COUNT(column_name) counts only non-NULL values in the specified column.|<pre><code>-- Counts all rows<br>SELECT COUNT() FROM Users;<br><br>-- Counts non-NULL emails<br>SELECT COUNT(Email) FROM Users;</code></pre>|
How do you filter groups created by GROUP BY?|Use the HAVING clause, which works like WHERE but applies to grouped results.|<pre><code>SELECT Country, COUNT(CustomerID) FROM Customers GROUP BY Country HAVING COUNT(CustomerID) > 5;</code></pre>|
What is the basic syntax for inserting data into a table?|Use the INSERT INTO statement.|<pre><code>INSERT INTO Customers (CustomerName, City) VALUES ('John Doe', 'New York');</code></pre>|
How do you update existing data in a table?|Use the UPDATE statement with a SET clause and typically a WHERE clause.|<pre><code>UPDATE Products SET Price = 12.50 WHERE ProductID = 101;</code></pre>|
How do you delete data from a table?|Use the DELETE FROM statement, usually with a WHERE clause to specify which rows to delete.|<pre><code>DELETE FROM Orders WHERE OrderStatus = 'Cancelled';</code></pre>|
What is the function of the LIMIT clause (or TOP/FETCH FIRST depending on SQL dialect)?|It restricts the number of rows returned by a query. LIMIT is common in MySQL/PostgreSQL, TOP in SQL Server, and FETCH FIRST in Oracle/SQL:2008.|<pre><code>-- MySQL/PostgreSQL<br>SELECT ProductName, Price FROM Products ORDER BY Price DESC LIMIT 10;<br><br>-- SQL Server<br>SELECT TOP 10 ProductName, Price FROM Products ORDER BY Price DESC;</code></pre>|
What is the AS keyword used for?|AS is used to give a table or a column a temporary name (an alias) within a query.|<pre><code>SELECT CustomerName AS Name, ContactName AS ContactPerson FROM Customers;</code></pre>|
Explain what NULL represents in SQL.|NULL represents a missing or unknown value. It is not the same as zero or an empty string.|<pre><code>SELECT * FROM Employees WHERE Email IS NULL;</code></pre>|
How do you test for NULL values in a WHERE clause?|You must use IS NULL or IS NOT NULL, not = or !=.|<pre><code>SELECT ProductName FROM Products WHERE Category IS NOT NULL;</code></pre>|
What are comparison operators in SQL?|Comparison operators are used in the WHERE clause to compare two expressions. Common examples include =, <, >, <=, >=, <> (or !=).| ||
What are logical operators in SQL?|Logical operators combine multiple conditions in a WHERE or HAVING clause. Common examples include AND, OR, and NOT.| ||
Scenario: You need to find all products with a price greater than $20 and less than $50. How would you write this query?|You would use the WHERE clause with the AND operator.|<pre><code>SELECT ProductName, Price FROM Products WHERE Price > 20 AND Price < 50;</code></pre>|
Scenario: You want to retrieve customers who live in 'London' or 'Paris'. How would you achieve this?|You would use the WHERE clause with the OR operator.|<pre><code>SELECT CustomerName, City FROM Customers WHERE City = 'London' OR City = 'Paris';</code></pre>|
What does the BETWEEN operator do?|The BETWEEN operator selects values within a given range, inclusive. It can be used for numbers, text, or dates.|<pre><code>SELECT ProductName, Price FROM Products WHERE Price BETWEEN 20 AND 30;</code></pre>|
What does the IN operator do?|The IN operator allows you to specify multiple values in a WHERE clause, acting as a shorthand for multiple OR conditions.|<pre><code>SELECT CustomerName, Country FROM Customers WHERE Country IN ('Germany', 'France', 'UK');</code></pre>|
What does the LIKE operator do?|The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.|<pre><code>SELECT CustomerName FROM Customers WHERE CustomerName LIKE 'A%'; -- Finds names starting with 'A'</code></pre>|
What are the wildcard characters used with the LIKE operator?|% (percentage sign) represents zero, one, or multiple characters. _ (underscore) represents a single character.|<pre><code>SELECT CustomerName FROM Customers WHERE CustomerName LIKE '_e%'; -- Finds names with 'e' as the second letter</code></pre>|
Scenario: Find all customer names that contain "son" anywhere in their name.|You would use the LIKE operator with the % wildcard on both sides of "son".|<pre><code>SELECT CustomerName FROM Customers WHERE CustomerName LIKE '%son%';</code></pre>|
What are aggregate functions in SQL?|Aggregate functions perform a calculation on a set of values (a column) and return a single summary value. They are often used with the GROUP BY clause.| ||
Name five common aggregate functions in SQL.|COUNT(), SUM(), AVG(), MIN(), MAX().| ||
How do you find the total amount of all orders in an Orders table with an Amount column?|Use the SUM() aggregate function.|<pre><code>SELECT SUM(Amount) FROM Orders;</code></pre>|
How do you find the average price of products in a Products table?|Use the AVG() aggregate function.|<pre><code>SELECT AVG(Price) FROM Products;</code></pre>|
How do you find the highest (maximum) salary in an Employees table?|Use the MAX() aggregate function.|<pre><code>SELECT MAX(Salary) FROM Employees;</code></pre>|
How do you find the lowest (minimum) stock quantity in a Stock table?|Use the MIN() aggregate function.|<pre><code>SELECT MIN(Quantity) FROM Stock;</code></pre>|
Explain the difference between LEFT JOIN and RIGHT JOIN.|A LEFT JOIN returns all rows from the left table, and matching rows from the right table. A RIGHT JOIN returns all rows from the right table, and matching rows from the left table. If no match, NULLs are returned for the non-matching side.|<pre><code>-- LEFT JOIN<br>SELECT A.col1, B.col2 FROM TableA A LEFT JOIN TableB B ON A.id = B.id;<br><br>-- RIGHT JOIN<br>SELECT A.col1, B.col2 FROM TableA A RIGHT JOIN TableB B ON A.id = B.id;</code></pre>|
What is a FULL OUTER JOIN?|A FULL OUTER JOIN returns all rows when there is a match in either the left or the right table. It includes all rows from both tables, with NULLs for non-matching columns.|<pre><code>SELECT A.col1, B.col2 FROM TableA A FULL OUTER JOIN TableB B ON A.id = B.id;</code></pre>|
What is a CROSS JOIN?|A CROSS JOIN returns the Cartesian product of the rows from the joined tables. This means it combines each row from the first table with every row from the second table, resulting in rows_table1 * rows_table2 total rows.|<pre><code>SELECT A.col1, B.col2 FROM TableA CROSS JOIN TableB;</code></pre>|
When would you use a SELF JOIN?|A SELF JOIN is a regular join where a table is joined with itself. It's used when you need to compare rows within the same table, for example, finding employees who report to a specific manager (where both are in the Employees table).|<pre><code>SELECT E1.Name AS EmployeeName, E2.Name AS ManagerName<br>FROM Employees E1<br>INNER JOIN Employees E2 ON E1.ManagerID = E2.EmployeeID;</code></pre>|
What is a subquery (or inner query) in SQL?|A subquery is a query nested inside another SQL query. It can be used in SELECT, INSERT, UPDATE, or DELETE statements, and often within WHERE, FROM, or HAVING clauses.| ||
Scenario: Find the names of customers who have placed at least one order. You have Customers and Orders tables.|You could use an INNER JOIN, or a subquery with EXISTS or IN.|<pre><code>-- Using INNER JOIN<br>SELECT DISTINCT C.CustomerName<br>FROM Customers C<br>INNER JOIN Orders O ON C.CustomerID = O.CustomerID;<br><br>-- Using subquery with EXISTS<br>SELECT CustomerName<br>FROM Customers<br>WHERE EXISTS (SELECT 1 FROM Orders WHERE Orders.CustomerID = Customers.CustomerID);<br><br>-- Using subquery with IN<br>SELECT CustomerName<br>FROM Customers<br>WHERE CustomerID IN (SELECT DISTINCT CustomerID FROM Orders);</code></pre>|
What is the ANY / SOME operator used with subqueries?|The ANY (or SOME) operator returns TRUE if any of the subquery values meet the condition. It is used with comparison operators (=, !=, <, >, etc.).|<pre><code>SELECT ProductName FROM Products<br>WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity > 10);</code></pre>|
What is the ALL operator used with subqueries?|The ALL operator returns TRUE if all of the subquery values meet the condition. It is used with comparison operators. It can mean "greater than all" or "less than all".|<pre><code>SELECT ProductName FROM Products<br>WHERE Price > ALL (SELECT Price FROM Products WHERE Category = 'Electronics');</code></pre>|
What is the UNION operator used for?|The UNION operator combines the result-set of two or more SELECT statements. All SELECT statements must have the same number of columns, and compatible data types, and they must be in the same order. UNION automatically removes duplicate rows.|<pre><code>SELECT City FROM Customers<br>UNION<br>SELECT City FROM Suppliers;</code></pre>|
What is the difference between UNION and UNION ALL?|UNION combines results and removes duplicate rows. UNION ALL combines results but does not remove duplicate rows, making it generally faster if duplicates are acceptable or desired.|<pre><code>SELECT City FROM Customers<br>UNION ALL<br>SELECT City FROM Suppliers;</code></pre>|
What is the INTERSECT operator used for?|The INTERSECT operator returns only the rows that are common to the result-sets of both SELECT statements.|<pre><code>SELECT City FROM Customers<br>INTERSECT<br>SELECT City FROM Employees;</code></pre>|
What is the EXCEPT (or MINUS in Oracle) operator used for?|The EXCEPT (or MINUS) operator returns all rows from the first SELECT statement that are not found in the second SELECT statement.|<pre><code>SELECT CustomerName FROM Customers<br>EXCEPT<br>SELECT CustomerName FROM Employees;</code></pre>|
What is a View in SQL?|A View is a virtual table based on the result-set of a SQL query. It contains rows and columns just like a real table, but it does not store data itself; it displays data stored in other tables.| ||Database view
When would you use a View?|Views are used to simplify complex queries, restrict data access (by showing only specific columns/rows), and aggregate data (for reporting). They can also improve security by hiding underlying table structures.| ||
How do you create a View?|Use the CREATE VIEW statement.|<pre><code>CREATE VIEW CustomerOrders AS<br>SELECT C.CustomerName, O.OrderID, O.OrderDate<br>FROM Customers C<br>INNER JOIN Orders O ON C.CustomerID = O.CustomerID;</code></pre>|
What is an Index in SQL?|An Index is a special lookup table that the database search engine can use to speed up data retrieval. It works much like an index in a book, pointing to the physical location of data.| ||Database index
Why are Indexes important for database performance?|Indexes significantly speed up SELECT queries by providing a fast way to locate data without scanning the entire table. However, they can slow down INSERT, UPDATE, and DELETE operations as the index also needs to be updated.| ||
What is the difference between a Clustered Index and a Non-Clustered Index?|A Clustered Index determines the physical order of data in a table, meaning the table's rows are physically sorted based on the clustered index key. A table can have only one clustered index. A Non-Clustered Index does not alter the physical order of table rows but creates a separate structure that contains the column values and pointers to the actual data rows. A table can have multiple non-clustered indexes.| ||
How do you create an Index?|Use the CREATE INDEX statement.|<pre><code>CREATE INDEX idx_customer_name<br>ON Customers (CustomerName);</code></pre>|
What is a Stored Procedure in SQL?|A Stored Procedure is a prepared SQL code that you can save and reuse. It's a collection of SQL statements that can be executed as a single unit, often used to encapsulate business logic.| ||
What are the benefits of using Stored Procedures?|Benefits include: improved performance (pre-compiled), reduced network traffic, improved security (can grant permission to execute without direct table access), and modularity/reusability of code.| ||
What is a Function in SQL (User-Defined Function)?|A Function in SQL is a subroutine that accepts input parameters, performs actions, and returns a single value. Unlike stored procedures, functions can be used within SQL statements (e.g., SELECT, WHERE).| ||
What is the difference between a Stored Procedure and a Function?|Return Value: Functions must return a value, procedures may or may not. Parameters: Functions can only have IN parameters, procedures can have IN, OUT, INOUT. Usage: Functions can be used in SQL statements (SELECT, WHERE), procedures cannot. Transactions: Procedures can control transactions (commit/rollback), functions usually cannot.| ||
What is a Trigger in SQL?|A Trigger is a special type of stored procedure that automatically executes when a specific event occurs in the database (e.g., INSERT, UPDATE, DELETE on a table).| ||
When would you use a Trigger?|Triggers are used for enforcing complex business rules, maintaining auditing trails, synchronizing data between tables, or validating input data before an operation.| ||
What is a Common Table Expression (CTE) in SQL?|A CTE is a named temporary result set that you can reference within a single SQL statement (SELECT, INSERT, UPDATE, DELETE). It is defined using the WITH clause and exists only for the duration of the query's execution.| ||
What are the benefits of using CTEs?|CTEs improve readability of complex queries, simplify subqueries, can be self-referencing (recursive CTEs), and help organize complex multi-step logic within a single query.| ||
Scenario: You want to find the average order value for each customer, but only for customers whose total order value is above $1000. How would you structure this with CTEs?|You can use a CTE to first calculate each customer's total order value, then reference this CTE in the main query to filter and calculate the average for the qualifying customers.|<pre><code>WITH CustomerTotalOrders AS (<br>    SELECT CustomerID, SUM(Amount) AS TotalOrderValue<br>    FROM Orders<br>    GROUP BY CustomerID<br>)<br>SELECT c.CustomerName, cto.TotalOrderValue, AVG(o.Amount) AS AvgOrderValue<br>FROM Customers c<br>JOIN CustomerTotalOrders cto ON c.CustomerID = cto.CustomerID<br>JOIN Orders o ON c.CustomerID = o.CustomerID<br>WHERE cto.TotalOrderValue > 1000<br>GROUP BY c.CustomerName, cto.TotalOrderValue;</code></pre>|
What is a Recursive CTE?|A Recursive CTE is a type of CTE that refers to itself. It's used to query hierarchical data (like organizational charts, bill of materials, or social network connections) by repeatedly executing the CTE until the entire hierarchy is traversed.| ||Recursive CTE concept
Explain the two parts of a Recursive CTE.|A recursive CTE has two parts: 1. An anchor member (non-recursive part) which is the initial query that defines the base result set. 2. A recursive member which references the CTE itself and defines how to combine previous results with new ones, until no new rows are returned. A UNION ALL (or UNION) combines these results.| ||
Scenario: You have an Employees table with EmployeeID and ManagerID. How would you list all employees under a specific manager, including indirect reports, using a recursive CTE?|You would start with the specific manager as the anchor, then recursively join the CTE to the Employees table on EmployeeID = ManagerID to find all direct and indirect reports.|<pre><code>WITH OrgHierarchy AS (<br>    SELECT EmployeeID, Name, ManagerID, 0 AS Level<br>    FROM Employees<br>    WHERE EmployeeID = [Starting_Manager_ID] -- Anchor member<br><br>    UNION ALL<br><br>    SELECT E.EmployeeID, E.Name, E.ManagerID, O.Level + 1<br>    FROM Employees E<br>    JOIN OrgHierarchy O ON E.ManagerID = O.EmployeeID -- Recursive member<br>)<br>SELECT EmployeeID, Name, Level FROM OrgHierarchy;</code></pre>|
What is a Window Function in SQL?|A Window Function performs a calculation across a set of table rows that are somehow related to the current row. Unlike aggregate functions (like GROUP BY), window functions do not group rows into a single output row; instead, they return a value for each row in the result set.|<pre><code>-- Example of a window function usage:<br>SELECT EmployeeID, Salary,<br>    AVG(Salary) OVER () AS AverageSalary<br>FROM Employees;</code></pre>|
Explain the OVER() clause in window functions.|The OVER() clause defines the "window" or set of rows on which the function operates. It can be empty for the entire result set, or include PARTITION BY to divide rows into groups and ORDER BY to specify the order within each partition.|<pre><code>SELECT EmployeeID, Salary,<br>    SUM(Salary) OVER (PARTITION BY DepartmentID ORDER BY HireDate) AS RunningSum<br>FROM Employees;</code></pre>|
What is the difference between an aggregate function with GROUP BY and a window function?|An aggregate function with GROUP BY collapses multiple rows into a single summary row. A window function, however, performs a calculation on a group of rows but returns a result for each individual row in the original query result set, without reducing the number of rows.|<pre><code>-- Aggregate with GROUP BY:<br>SELECT DepartmentID, AVG(Salary) FROM Employees GROUP BY DepartmentID;<br><br>-- Window function (retains original rows):<br>SELECT EmployeeID, DepartmentID, Salary, AVG(Salary) OVER (PARTITION BY DepartmentID) AS DeptAvgSalary FROM Employees;</code></pre>|
What does the ROW_NUMBER() window function do?|ROW_NUMBER() assigns a unique, sequential integer to each row within its partition, based on the specified order. The numbering starts at 1 for the first row in each partition.|<pre><code>SELECT EmployeeID, DepartmentID, Salary,<br>    ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS RankWithinDept<br>FROM Employees;</code></pre>|
How can you get the top N rows within each group using ROW_NUMBER()?|To get the top N rows within each group, you can use ROW_NUMBER() with PARTITION BY and ORDER BY in a subquery or CTE, and then filter for rows where ROW_NUMBER() is less than or equal to N.|<pre><code>WITH RankedEmployees AS (<br>    SELECT EmployeeID, DepartmentID, Salary,<br>        ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS rn<br>    FROM Employees<br>)<br>SELECT EmployeeID, DepartmentID, Salary FROM RankedEmployees WHERE rn <= N;</code></pre>|
Explain the difference between RANK() and DENSE_RANK() window functions.|RANK() assigns a rank to each row within a partition. If there are ties, they receive the same rank, and the next rank is skipped (e.g., 1, 2, 2, 4). DENSE_RANK() also assigns a rank, but if there are ties, the next rank is consecutive (e.g., 1, 2, 2, 3), with no gaps.|<pre><code>SELECT EmployeeID, Salary,<br>    RANK() OVER (ORDER BY Salary DESC) AS RankSalary,<br>    DENSE_RANK() OVER (ORDER BY Salary DESC) AS DenseRankSalary<br>FROM Employees;</code></pre>|
What is the NTILE(N) window function used for?|NTILE(N) divides the rows in a partition into N groups, assigning an integer from 1 to N to each group. Rows are distributed as evenly as possible.|<pre><code>SELECT CustomerID, OrderTotal,<br>    NTILE(4) OVER (ORDER BY OrderTotal DESC) AS Quartile<br>FROM Orders; -- Divides customers into 4 quartiles by order total</code></pre>|
Scenario: You have a table Sales with SaleID, SaleDate, and Amount. You want to calculate the running total of Amount for each SaleDate (cumulative sum). How would you do this?|You would use SUM() as a window function with an ORDER BY clause to define the cumulative order. If you need it per specific group (e.g., per region), you'd add PARTITION BY.|<pre><code>SELECT SaleID, SaleDate, Amount,<br>    SUM(Amount) OVER (ORDER BY SaleDate) AS RunningTotal<br>FROM Sales ORDER BY SaleDate;</code></pre>|
Scenario: You have Employees table with DepartmentID and Salary. Find the difference between an employee's salary and the average salary of their department.|You would use a window function AVG(Salary) partitioned by DepartmentID to get the departmental average for each row, and then subtract it from the individual salary.|<pre><code>SELECT EmployeeID, DepartmentID, Salary,<br>    Salary - AVG(Salary) OVER (PARTITION BY DepartmentID) AS SalaryDifferenceFromDeptAvg<br>FROM Employees;</code></pre>|
What are LAG() and LEAD() window functions used for?|LAG(column, offset, default) retrieves a value from a preceding row within the partition at a given offset. LEAD(column, offset, default) retrieves a value from a subsequent row within the partition at a given offset. They are useful for comparing values between rows.|<pre><code>SELECT SaleDate, SalesAmount,<br>    LAG(SalesAmount, 1, 0) OVER (ORDER BY SaleDate) AS PreviousDaySales,<br>    LEAD(SalesAmount, 1, 0) OVER (ORDER BY SaleDate) AS NextDaySales<br>FROM DailySales;</code></pre>|
Scenario: In a time-series dataset of daily stock prices, how would you calculate the day-over-day price change?|You would use LAG() to get the previous day's closing price and then subtract it from the current day's closing price. ORDER BY the date is crucial.|<pre><code>SELECT TradeDate, ClosePrice,<br>    ClosePrice - LAG(ClosePrice, 1, ClosePrice) OVER (ORDER BY TradeDate) AS DayOverDayChange<br>FROM StockPrices;</code></pre>|
What is a Frame Clause in window functions and what keywords are used?|A Frame Clause defines the subset of rows within a partition on which a window function operates. It is specified within the OVER() clause using keywords like ROWS, RANGE, CURRENT ROW, PRECEDING, and FOLLOWING.|<pre><code>SELECT SaleDate, Amount,<br>    SUM(Amount) OVER (ORDER BY SaleDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS SumLast3Days<br>FROM DailySales;</code></pre>|
Explain ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.|This frame clause defines the window from the very first row in the partition (or result set if no PARTITION BY) up to and including the current row. It's commonly used for cumulative sums.|<pre><code>SELECT OrderID, OrderDate, OrderTotal,<br>    SUM(OrderTotal) OVER (ORDER BY OrderDate ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CumulativeOrderTotal<br>FROM Orders;</code></pre>|
Scenario: Calculate a 3-day moving average of sales from a DailySales table with SaleDate and Amount.|You would use AVG(Amount) as a window function with an ORDER BY clause and a ROWS BETWEEN frame clause to include the current row and the two preceding rows.|<pre><code>SELECT SaleDate, Amount,<br>    AVG(Amount) OVER (ORDER BY SaleDate ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS ThreeDayMovingAverage<br>FROM DailySales;</code></pre>|
What are FIRST_VALUE() and LAST_VALUE() window functions?|FIRST_VALUE(column) returns the value of the specified column from the first row in the current window frame. LAST_VALUE(column) returns the value from the last row in the current window frame. You often need to specify a frame clause for LAST_VALUE() to work as expected.|<pre><code>SELECT ProductID, Price, SaleDate,<br>    FIRST_VALUE(Price) OVER (PARTITION BY ProductID ORDER BY SaleDate) AS InitialPrice,<br>    LAST_VALUE(Price) OVER (PARTITION BY ProductID ORDER BY SaleDate ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS LatestPrice<br>FROM ProductPricesHistory;</code></pre>|
What is NTH_VALUE(column, N) window function used for?|NTH_VALUE(column, N) returns the value of the specified column from the Nth row in the current window frame. It's useful for finding specific values like the 2nd highest, 3rd lowest, etc., within a window.|<pre><code>SELECT EmployeeID, DepartmentID, Salary,<br>    NTH_VALUE(Salary, 2) OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS SecondHighestSalaryInDept<br>FROM Employees;</code></pre>|
Scenario: Find the percentage of an individual employee's salary relative to their department's total salary.|You would use SUM(Salary) as a window function partitioned by DepartmentID to get the departmental total, then divide the individual salary by this sum.|<pre><code>SELECT EmployeeID, DepartmentID, Salary,<br>    (Salary * 100.0) / SUM(Salary) OVER (PARTITION BY DepartmentID) AS PercentOfDeptSalary<br>FROM Employees;</code></pre>|
What is CUME_DIST() window function?|CUME_DIST() calculates the cumulative distribution of a value within a partition. It represents the relative position of a value within its partition, as a percentile (0 to 1). It returns (number of rows preceding or peer with current row) / (total rows in partition).|<pre><code>SELECT StudentID, Score,<br>    CUME_DIST() OVER (ORDER BY Score) AS PercentileRank<br>FROM ExamScores;</code></pre>|
What is PERCENT_RANK() window function?|PERCENT_RANK() calculates the relative rank of each row within its partition, as a percentile (0 to 1). It returns (rank - 1) / (rows in partition - 1). This is often used to understand a row's position relative to others.|<pre><code>SELECT EmployeeID, Salary,<br>    PERCENT_RANK() OVER (ORDER BY Salary DESC) AS SalaryPercentRank<br>FROM Employees;</code></pre>|
Scenario: You have Transactions with TransactionID, CustomerID, TransactionDate, Amount. You want to find the previous transaction amount for each customer.|You would use the LAG() function, partitioned by CustomerID and ordered by TransactionDate, to get the Amount of the preceding transaction.|<pre><code>SELECT TransactionID, CustomerID, TransactionDate, Amount,<br>    LAG(Amount, 1, 0) OVER (PARTITION BY CustomerID ORDER BY TransactionDate) AS PreviousTransactionAmount<br>FROM Transactions;</code></pre>|
Scenario: Find the first order placed by each customer.|You can use ROW_NUMBER() partitioned by CustomerID and ordered by OrderDate and then filter for rn = 1.|<pre><code>WITH RankedOrders AS (<br>    SELECT CustomerID, OrderID, OrderDate, Amount,<br>        ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate ASC) AS rn<br>    FROM Orders<br>)<br>SELECT CustomerID, OrderID, OrderDate, Amount<br>FROM RankedOrders<br>WHERE rn = 1;</code></pre>|
What is a CASE statement in SQL?|A CASE statement is a conditional expression that allows you to specify different results based on different conditions. It functions like if-then-else logic in other programming languages.| ||Case statement logic
Scenario: You have an Orders table with an Amount column. Categorize each order as 'Small' (<=100), 'Medium' (>100 and <=500), or 'Large' (>500).|You would use a CASE statement in your SELECT clause to define the categories based on the Amount.|<pre><code>SELECT OrderID, Amount,<br>    CASE<br>        WHEN Amount <= 100 THEN 'Small'<br>        WHEN Amount > 100 AND Amount <= 500 THEN 'Medium'<br>        ELSE 'Large'<br>    END AS OrderCategory<br>FROM Orders;</code></pre>|
What is the difference between NULLIF and COALESCE?|NULLIF(expression1, expression2) returns NULL if expression1 equals expression2, otherwise it returns expression1. COALESCE(expression1, expression2, ...) returns the first non-NULL expression in the list. COALESCE is often used for handling default values when a column might be NULL.|<pre><code>SELECT NULLIF(TotalSales, 0); -- Returns NULL if TotalSales is 0<br>SELECT COALESCE(Email, 'No Email Provided'); -- Returns 'No Email Provided' if Email is NULL</code></pre>|
What is the purpose of the DISTINCT ON clause (PostgreSQL specific)?|DISTINCT ON is a PostgreSQL-specific extension to SELECT DISTINCT that allows you to return the first row of each set of rows that are distinct on a specified expression. It must be used with ORDER BY.|<pre><code>SELECT DISTINCT ON (customer_id) customer_id, order_date, order_amount<br>FROM orders<br>ORDER BY customer_id, order_date DESC; -- Gets the latest order for each customer</code></pre>|
Scenario: From a table ExamScores with StudentID, Subject, and Score, find the student's highest score in each subject.|You can use MAX() with GROUP BY Subject or ROW_NUMBER() partitioned by subject and ordered by score descending.|<pre><code>-- Using GROUP BY<br>SELECT Subject, StudentID, MAX(Score) AS HighestScore<br>FROM ExamScores<br>GROUP BY Subject, StudentID;<br><br>-- Using ROW_NUMBER()<br>WITH RankedScores AS (<br>    SELECT StudentID, Subject, Score,<br>        ROW_NUMBER() OVER (PARTITION BY Subject ORDER BY Score DESC) AS rn<br>    FROM ExamScores<br>)<br>SELECT StudentID, Subject, Score<br>FROM RankedScores<br>WHERE rn = 1;</code></pre>|
What are SQL Constraints?|SQL Constraints are rules enforced on data columns of a table to limit the type of data that can go into it. They ensure the accuracy and reliability of the data in the database.| ||
Name five common SQL Constraints.|NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK, DEFAULT.| ||
What is the NOT NULL constraint?|The NOT NULL constraint ensures that a column cannot have a NULL value. It ensures that data is always present in that column.|<pre><code>CREATE TABLE Employees (<br>    EmployeeID INT PRIMARY KEY,<br>    FirstName VARCHAR(255) NOT NULL<br>);</code></pre>|
What is the UNIQUE constraint?|The UNIQUE constraint ensures that all values in a column are different. It allows NULL values, but only one NULL value per column if no other UNIQUE constraint is defined on it.|<pre><code>CREATE TABLE Users (<br>    UserID INT PRIMARY KEY,<br>    Email VARCHAR(255) UNIQUE<br>);</code></pre>|
What is the CHECK constraint?|The CHECK constraint is used to limit the value range that can be placed in a column. It enforces a condition that must be true for each row.|<pre><code>CREATE TABLE Products (<br>    ProductID INT PRIMARY KEY,<br>    Price DECIMAL(10, 2) CHECK (Price > 0)<br>);</code></pre>|
What is the DEFAULT constraint?|The DEFAULT constraint is used to set a default value for a column. If no value is specified for the column when inserting a new row, the default value will be added.|<pre><code>CREATE TABLE Orders (<br>    OrderID INT PRIMARY KEY,<br>    OrderDate DATE DEFAULT GETDATE() -- Or CURRENT_DATE for MySQL/PostgreSQL<br>);</code></pre>|
How do you add a NOT NULL constraint to an existing column?|Use the ALTER TABLE ALTER COLUMN (or MODIFY COLUMN) statement.|<pre><code>ALTER TABLE Employees<br>ALTER COLUMN LastName VARCHAR(255) NOT NULL; -- SQL Server<br><br>-- MySQL/PostgreSQL:<br>ALTER TABLE Employees<br>MODIFY COLUMN LastName VARCHAR(255) NOT NULL;</code></pre>|
How do you add a UNIQUE constraint to an existing column?|Use the ALTER TABLE ADD CONSTRAINT statement.|<pre><code>ALTER TABLE Users<br>ADD CONSTRAINT UQ_Email UNIQUE (Email);</code></pre>|
How do you drop an existing constraint?|Use the ALTER TABLE DROP CONSTRAINT statement, specifying the constraint name.|<pre><code>ALTER TABLE Users<br>DROP CONSTRAINT UQ_Email; -- Replace UQ_Email with the actual constraint name</code></pre>|
What is an SQL Transaction?|An SQL Transaction is a single logical unit of work. It is a sequence of operations performed as a single logical unit. All operations within a transaction must be completed successfully, or none of them are (Atomicity).| ||Transaction ACID
What are the ACID properties of transactions?|Atomicity: All or nothing. Consistency: Transaction brings database from one valid state to another. Isolation: Concurrent transactions don't interfere. Durability: Committed changes are permanent.| ||
What are COMMIT and ROLLBACK in transactions?|COMMIT saves all changes made during the current transaction permanently to the database. ROLLBACK undoes all changes made during the current transaction, restoring the database to its state before the transaction began.|<pre><code>BEGIN TRANSACTION;<br>UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;<br>UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;<br>COMMIT; -- Or ROLLBACK; if an error occurs</code></pre>|
What is the BEGIN TRANSACTION (or START TRANSACTION) statement?|It initiates a new transaction block, signaling that the subsequent SQL statements should be treated as a single, atomic unit of work until a COMMIT or ROLLBACK is issued.|<pre><code>BEGIN TRANSACTION;<br>-- SQL statements here<br>COMMIT;</code></pre>|
Scenario: You are transferring money between two bank accounts. How would you ensure the operation is atomic (either both updates succeed or neither do)?|You would wrap the two UPDATE statements within a transaction, using BEGIN TRANSACTION and COMMIT. If any error occurs, you would ROLLBACK.|<pre><code>BEGIN TRANSACTION;<br>UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;<br>UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;<br>-- Check for errors after each update (e.g., insufficient funds)<br>IF @@ERROR = 0 AND [no other business logic errors] THEN<br>    COMMIT;<br>ELSE<br>    ROLLBACK;<br>END IF;</code></pre>|
What is a Savepoint in SQL transactions?|A Savepoint allows you to set a point within a transaction to which you can later roll back, without rolling back the entire transaction. This is useful for complex transactions where you might want to undo only a portion of the work.|<pre><code>BEGIN TRANSACTION;<br>INSERT INTO Orders ...;<br>SAVEPOINT OrderSave;<br>INSERT INTO OrderDetails ...;<br>-- If OrderDetails insert fails, you can:<br>ROLLBACK TO SAVEPOINT OrderSave;<br>-- Then continue or try something else<br>COMMIT;</code></pre>|
What is SQL Injection?|SQL Injection is a code injection technique used to attack data-driven applications, in which malicious SQL statements are inserted into an entry field for execution (e.g., to dump database contents to the attacker).| ||SQL injection diagram
How can SQL Injection be prevented?|The primary ways to prevent SQL Injection are: Parameterized Queries (Prepared Statements), using Stored Procedures with parameters, and Input Validation (though validation alone is not sufficient for full prevention).| ||
What is an EXPLAIN (or EXPLAIN ANALYZE / SET AUTOTRACE ON) statement used for?|EXPLAIN (the exact keyword varies by database) is used to analyze how a SQL query is executed by the database engine. It provides insights into the query plan, including join order, index usage, and table scans, which is crucial for performance tuning.|<pre><code>EXPLAIN SELECT * FROM Employees WHERE DepartmentID = 5;</code></pre>|
What are different types of SELECT clauses/operations you can perform?|SELECT is used for projection (choosing columns), filtering (with WHERE), joining (with JOIN), grouping (with GROUP BY), ordering (with ORDER BY), limiting results (LIMIT), and performing calculations (aggregate and window functions).| ||
What is a temporary table in SQL?|A temporary table is a special type of table that stores a subset of data temporarily. It is session-specific, meaning it is only visible and accessible during the current user session and is automatically dropped when the session ends or when explicitly dropped.| ||
When would you use a temporary table?|Temporary tables are useful for breaking down complex queries into smaller, manageable steps, storing intermediate results, or performing complex joins/manipulations that are too difficult or inefficient with subqueries or CTEs.|<pre><code>CREATE TEMPORARY TABLE TempSales AS<br>SELECT ProductID, SUM(Amount) AS TotalSales<br>FROM Sales<br>GROUP BY ProductID;<br><br>SELECT * FROM TempSales WHERE TotalSales > 1000;</code></pre>|
What is a Common Table Expression (CTE) versus a Subquery?|Both help organize complex queries. A CTE is named and can be referenced multiple times within the same query, improving readability and reusability. A subquery is typically anonymous and nested within another statement, often making complex queries harder to read if deeply nested. CTEs also support recursion.| ||CTE vs Subquery
Scenario: You have Customers and Orders tables. Find customers who have not placed any orders.|You can use a LEFT JOIN and check for NULL values in the right table's key, or use NOT EXISTS with a subquery.|<pre><code>-- Using LEFT JOIN<br>SELECT C.CustomerName<br>FROM Customers C<br>LEFT JOIN Orders O ON C.CustomerID = O.CustomerID<br>WHERE O.OrderID IS NULL;<br><br>-- Using NOT EXISTS<br>SELECT CustomerName<br>FROM Customers<br>WHERE NOT EXISTS (SELECT 1 FROM Orders WHERE Orders.CustomerID = Customers.CustomerID);</code></pre>|
What are Scalar Functions in SQL?|Scalar functions operate on a single input value and return a single output value. They can be used anywhere an expression is valid.| ||
Name five common Scalar Functions in SQL.|UPPER(), LOWER(), LENGTH() (or LEN()), ROUND(), CONCAT() (or + for concatenation).| ||
Scenario: Format a customer's FirstName and LastName into a single FullName with proper capitalization.|You would use string concatenation and UPPER() for the first letter of each part, or INITCAP() if available.|<pre><code>-- Example for MySQL/PostgreSQL<br>SELECT CONCAT(UPPER(SUBSTRING(FirstName, 1, 1)), LOWER(SUBSTRING(FirstName, 2)), ' ',<br>              UPPER(SUBSTRING(LastName, 1, 1)), LOWER(SUBSTRING(LastName, 2))) AS FullName<br>FROM Customers;<br><br>-- Simpler if INITCAP or similar is available (e.g., Oracle, some PostgreSQL extensions)<br>SELECT INITCAP(FirstName || ' ' || LastName) AS FullName FROM Customers;</code></pre>|
What is the HAVING clause primarily used for, in contrast to WHERE?|WHERE filters individual rows before grouping and aggregation. HAVING filters groups after GROUP BY and aggregation has occurred, allowing conditions on aggregate function results.| ||WHERE vs HAVING
Scenario: Find departments where the average employee salary is above $60,000.|You would group by DepartmentID and then use HAVING to filter the grouped results based on the AVG(Salary).|<pre><code>SELECT DepartmentID, AVG(Salary) AS AverageSalary<br>FROM Employees<br>GROUP BY DepartmentID<br>HAVING AVG(Salary) > 60000;</code></pre>|
What is the purpose of GRANT and REVOKE statements?|GRANT is a DCL command used to give specific privileges to users or roles (e.g., SELECT, INSERT, UPDATE on tables). REVOKE is used to remove those previously granted privileges.|<pre><code>GRANT SELECT, INSERT ON Customers TO 'data_analyst';<br>REVOKE DELETE ON Orders FROM 'data_analyst';</code></pre>|
What is Normalization in database design?|Normalization is the process of organizing data in a database to reduce data redundancy and improve data integrity. It involves breaking down large tables into smaller, related tables and defining relationships between them.| ||Database normalization
What are the first three Normal Forms (1NF, 2NF, 3NF)?|1NF (First Normal Form): Each column contains atomic (indivisible) values, and there are no repeating groups of columns. 2NF (Second Normal Form): It must be in 1NF, and all non-key attributes must be fully dependent on the primary key (no partial dependencies). 3NF (Third Normal Form): It must be in 2NF, and all non-key attributes must be dependent only on the primary key, not on other non-key attributes (no transitive dependencies).| ||
What is Denormalization?|Denormalization is the process of intentionally introducing redundancy into a database by combining data from multiple tables into one, typically to improve query performance for specific reporting or analytical needs, often at the cost of some data integrity risk.| ||
When would you consider Denormalization?|Denormalization is considered when read performance is critical and joins are becoming a bottleneck, especially in data warehousing or OLAP (Online Analytical Processing) environments where data redundancy is less of a concern than query speed.| ||
What is a Schema in SQL?|A Schema is a collection of database objects (tables, views, indexes, stored procedures, functions) associated with a particular database user or application. It provides a logical grouping of related objects.| ||Database schema
What is an Alias and when is it useful?|An Alias is a temporary name given to a table or a column in a SQL query using the AS keyword. It's useful for making column names more readable, shortening table names for joins, and handling self-joins to distinguish between instances of the same table.|<pre><code>SELECT C.CustomerName, O.OrderDate<br>FROM Customers AS C<br>INNER JOIN Orders AS O ON C.CustomerID = O.CustomerID;</code></pre>|
Scenario: You want to count the number of orders placed by each customer, including customers who have placed no orders. Which join type would you use and why?|You would use a LEFT JOIN from Customers to Orders because it returns all customers (from the "left" table) and matches them with orders, showing NULL for customers without orders. Then use COUNT(O.OrderID) to count non-null orders.|<pre><code>SELECT C.CustomerName, COUNT(O.OrderID) AS NumberOfOrders<br>FROM Customers C<br>LEFT JOIN Orders O ON C.CustomerID = O.CustomerID<br>GROUP BY C.CustomerName<br>ORDER BY C.CustomerName;</code></pre>|
How do you handle NULL values in aggregate functions (e.g., AVG, SUM)?|Most aggregate functions (SUM, AVG, MIN, MAX, COUNT(column_name)) ignore NULL values by default. COUNT(*) counts rows regardless of NULLs.|<pre><code>-- AVG will ignore NULL scores<br>SELECT AVG(Score) FROM Students;</code></pre>|
What is a Composite Primary Key?|A Composite Primary Key is a primary key that consists of two or more columns whose values, when combined, uniquely identify each row in a table. Each column alone might not be unique, but their combination is.| ||
When would you use a Composite Primary Key?|It's used when a single column cannot uniquely identify a record, but a combination of columns can. Common in many-to-many relationships (e.g., a OrderDetails table might have OrderID and ProductID as a composite primary key).| ||
What is an SQL Injection attack and how does it compromise a database?|An SQL Injection attack exploits vulnerabilities in web applications that use SQL queries by inserting malicious SQL code into input fields. This can allow attackers to bypass authentication, extract sensitive data, modify database records, or even gain control over the database server.| ||SQL injection diagram
What is the HAVING clause primarily used for?|The HAVING clause is used to filter the results of a GROUP BY clause. It is applied to the aggregate values, whereas the WHERE clause filters individual rows before aggregation.|<pre><code>SELECT DepartmentID, AVG(Salary)<br>FROM Employees<br>GROUP BY DepartmentID<br>HAVING AVG(Salary) > 50000;</code></pre>|
Scenario: From a Products table with Category and Price, find the categories where the average price is above $100 and the category name is not 'Electronics'.|You would GROUP BY Category, then use HAVING for the average price condition and WHERE for the category name condition.|<pre><code>SELECT Category, AVG(Price) AS AvgPrice<br>FROM Products<br>WHERE Category != 'Electronics'<br>GROUP BY Category<br>HAVING AVG(Price) > 100;</code></pre>|
What is a Non-Equi Join?|A Non-Equi Join is a join that uses comparison operators other than equals (=) in its join condition (e.g., <, >, <=, >=, BETWEEN). They are less common than equi-joins but useful for specific types of analysis like range-based lookups.|<pre><code>SELECT E.Name, S.Grade<br>FROM Employees E<br>JOIN SalaryRanges S ON E.Salary BETWEEN S.MinSalary AND S.MaxSalary;</code></pre>|
What is a SET operator in SQL?|SET operators (UNION, UNION ALL, INTERSECT, EXCEPT/MINUS) combine the results of two or more SELECT statements into a single result set.| ||
What is the purpose of TRUNCATE TABLE versus DELETE FROM table (without WHERE)?|TRUNCATE TABLE is a DDL command that quickly removes all rows from a table by deallocating the data pages, resetting identity columns, and is usually non-transactional (cannot be rolled back). DELETE FROM table is a DML command that removes rows one by one, logs each deleted row, and is transactional (can be rolled back). TRUNCATE is faster for emptying an entire table.|<pre><code>TRUNCATE TABLE LargeLogTable;<br><br>DELETE FROM Customers; -- This can be rolled back</code></pre>|
How do you rename a table in SQL?|Use the ALTER TABLE RENAME TO (PostgreSQL/MySQL) or sp_rename (SQL Server) statement.|<pre><code>ALTER TABLE OldTableName RENAME TO NewTableName; -- PostgreSQL/MySQL<br><br>EXEC sp_rename 'OldTableName', 'NewTableName'; -- SQL Server</code></pre>|
How do you rename a column in SQL?|Use the ALTER TABLE RENAME COLUMN (PostgreSQL) or CHANGE COLUMN (MySQL) or sp_rename (SQL Server) statement.|<pre><code>ALTER TABLE Customers RENAME COLUMN OldName TO NewName; -- PostgreSQL<br><br>ALTER TABLE Customers CHANGE COLUMN OldName NewName VARCHAR(255); -- MySQL<br><br>EXEC sp_rename 'Customers.OldName', 'NewName', 'COLUMN'; -- SQL Server</code></pre>|
What is the purpose of CAST() or CONVERT() functions?|These functions are used to convert an expression of one data type to another. CAST() is standard SQL; CONVERT() is specific to some databases like SQL Server.|<pre><code>SELECT CAST('123' AS INT);<br>SELECT CONVERT(INT, '123');</code></pre>|
Scenario: You have a Sales table with SaleDate stored as TEXT in 'YYYY-MM-DD' format. How would you convert it to a DATE type for date calculations?|You would use CAST() or CONVERT() to change the data type.|<pre><code>SELECT SaleDate, CAST(SaleDate AS DATE) AS ConvertedDate<br>FROM Sales<br>WHERE CAST(SaleDate AS DATE) > '2023-01-01';</code></pre>|
What is the ISNULL() (SQL Server) or IFNULL() (MySQL) or COALESCE() (Standard SQL) function used for?|These functions are used to replace NULL values with a specified alternative value. COALESCE() is the most portable as it is part of the SQL standard.|<pre><code>SELECT ProductName, COALESCE(Description, 'No description available') AS ProductDescription<br>FROM Products;</code></pre>|
Scenario: You are retrieving product prices, but some Discount values might be NULL. If Discount is NULL, you want to treat it as 0 for calculation. How would you do this?|You would use COALESCE() (or ISNULL/IFNULL) on the Discount column.|<pre><code>SELECT ProductName, Price - COALESCE(Discount, 0) AS FinalPrice<br>FROM Products;</code></pre>|
What is a Common Table Expression (CTE) and how does it differ from a subquery?|A CTE (Common Table Expression) is a named, temporary result set that you can reference within a single SQL statement. It improves readability and can be recursive. A subquery is an unnamed query nested within another query, typically less readable when complex or deeply nested, and cannot be recursive.| ||CTE vs Subquery
What is the meaning of CRUD in database operations?|CRUD stands for Create, Read, Update, and Delete. These are the four basic functions of persistent storage that an application needs to manipulate data.| ||CRUD operations